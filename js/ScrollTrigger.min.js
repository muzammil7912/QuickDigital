/*!
 * ScrollTrigger 3.12.3
 * https://greensock.com
 * 
 * @license Copyright 2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */

! function(e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = e || self).window = e.window || {}) }(this, function(e) {
    "use strict";

    function _defineProperties(e, t) {
        for (var r = 0; r < t.length; r++) {
            var n = t[r];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
        }
    }

    function r() { return _e || "undefined" != typeof window && (_e = window.gsap) && _e.registerPlugin && _e }

    function z(e, t) { return ~Le.indexOf(e) && Le[Le.indexOf(e) + 1][t] }

    function A(e) { return !!~t.indexOf(e) }

    function B(e, t, r, n, i) { return e.addEventListener(t, r, { passive: !n, capture: !!i }) }

    function C(e, t, r, n) { return e.removeEventListener(t, r, !!n) }

    function F() { return Ae && Ae.isPressed || Ie.cache++ }

    function G(r, n) {
        function cd(e) {
            if (e || 0 === e) {
                i && (Se.history.scrollRestoration = "manual");
                var t = Ae && Ae.isPressed;
                e = cd.v = Math.round(e) || (Ae && Ae.iOS ? 1 : 0), r(e), cd.cacheID = Ie.cache, t && o("ss", e)
            } else(n || Ie.cache !== cd.cacheID || o("ref")) && (cd.cacheID = Ie.cache, cd.v = r());
            return cd.v + cd.offset
        }
        return cd.offset = 0, r && cd
    }

    function J(e, t) { return (t && t._ctx && t._ctx.selector || _e.utils.toArray)(e)[0] || ("string" == typeof e && !1 !== _e.config().nullTargetWarn ? console.warn("Element not found:", e) : null) }

    function K(t, e) {
        var r = e.s,
            n = e.sc;
        A(t) && (t = Ce.scrollingElement || ke);
        var i = Ie.indexOf(t),
            o = n === Ye.sc ? 1 : 2;
        ~i || (i = Ie.push(t) - 1), Ie[i + o] || B(t, "scroll", F);
        var a = Ie[i + o],
            s = a || (Ie[i + o] = G(z(t, r), !0) || (A(t) ? n : G(function(e) { return arguments.length ? t[r] = e : t[r] })));
        return s.target = t, a || (s.smooth = "smooth" === _e.getProperty(t, "scrollBehavior")), s
    }

    function L(e, t, i) {
        function Bd(e, t) {
            var r = qe();
            t || n < r - s ? (a = o, o = e, l = s, s = r) : i ? o += e : o = a + (e - a) / (r - l) * (s - l)
        }
        var o = e,
            a = e,
            s = qe(),
            l = s,
            n = t || 50,
            c = Math.max(500, 3 * n);
        return {
            update: Bd,
            reset: function reset() { a = o = i ? 0 : o, l = s = 0 },
            getVelocity: function getVelocity(e) {
                var t = l,
                    r = a,
                    n = qe();
                return !e && 0 !== e || e === o || Bd(e), s === l || c < n - l ? 0 : (o + (i ? r : -r)) / ((i ? n : s) - t) * 1e3
            }
        }
    }

    function M(e, t) { return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e }

    function N(e) {
        var t = Math.max.apply(Math, e),
            r = Math.min.apply(Math, e);
        return Math.abs(t) >= Math.abs(r) ? t : r
    }

    function O() {
        (Oe = _e.core.globals().ScrollTrigger) && Oe.core && function _integrate() {
            var e = Oe.core,
                r = e.bridge || {},
                t = e._scrollers,
                n = e._proxies;
            t.push.apply(t, Ie), n.push.apply(n, Le), Ie = t, Le = n, o = function _bridge(e, t) { return r[e](t) }
        }()
    }

    function P(e) { return (_e = e || r()) && "undefined" != typeof document && document.body && (Se = window, ke = (Ce = document).documentElement, Pe = Ce.body, t = [Se, Ce, ke, Pe], _e.utils.clamp, Re = _e.core.context || function() {}, Ee = "onpointerenter" in Pe ? "pointer" : "mouse", Me = k.isTouch = Se.matchMedia && Se.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in Se || 0 < navigator.maxTouchPoints || 0 < navigator.msMaxTouchPoints ? 2 : 0, De = k.eventTypes = ("ontouchstart" in ke ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in ke ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function() { return i = 0 }, 500), O(), Te = 1), Te }
    var _e, Te, Se, Ce, ke, Pe, Me, Ee, Oe, t, Ae, De, Re, i = 1,
        Be = [],
        Ie = [],
        Le = [],
        qe = Date.now,
        o = function _bridge(e, t) { return t },
        n = "scrollLeft",
        a = "scrollTop",
        ze = { s: n, p: "left", p2: "Left", os: "right", os2: "Right", d: "width", d2: "Width", a: "x", sc: G(function(e) { return arguments.length ? Se.scrollTo(e, Ye.sc()) : Se.pageXOffset || Ce[n] || ke[n] || Pe[n] || 0 }) },
        Ye = { s: a, p: "top", p2: "Top", os: "bottom", os2: "Bottom", d: "height", d2: "Height", a: "y", op: ze, sc: G(function(e) { return arguments.length ? Se.scrollTo(ze.sc(), e) : Se.pageYOffset || Ce[a] || ke[a] || Pe[a] || 0 }) };
    ze.op = Ye, Ie.cache = 0;
    var k = (Observer.prototype.init = function init(e) {
        Te || P(_e) || console.warn("Please gsap.registerPlugin(Observer)"), Oe || O();
        var i = e.tolerance,
            a = e.dragMinimum,
            t = e.type,
            o = e.target,
            r = e.lineHeight,
            n = e.debounce,
            s = e.preventDefault,
            l = e.onStop,
            c = e.onStopDelay,
            u = e.ignore,
            f = e.wheelSpeed,
            d = e.event,
            p = e.onDragStart,
            g = e.onDragEnd,
            h = e.onDrag,
            v = e.onPress,
            b = e.onRelease,
            m = e.onRight,
            y = e.onLeft,
            x = e.onUp,
            w = e.onDown,
            _ = e.onChangeX,
            T = e.onChangeY,
            S = e.onChange,
            k = e.onToggleX,
            E = e.onToggleY,
            D = e.onHover,
            R = e.onHoverEnd,
            I = e.onMove,
            q = e.ignoreCheck,
            z = e.isNormalizer,
            Y = e.onGestureStart,
            H = e.onGestureEnd,
            X = e.onWheel,
            W = e.onEnable,
            V = e.onDisable,
            U = e.onClick,
            G = e.scrollSpeed,
            Q = e.capture,
            j = e.allowClicks,
            Z = e.lockAxis,
            $ = e.onLockAxis;

        function af() { return ye = qe() }

        function bf(e, t) { return (se.event = e) && u && ~u.indexOf(e.target) || t && ge && "touch" !== e.pointerType || q && q(e, t) }

        function df() {
            var e = se.deltaX = N(be),
                t = se.deltaY = N(me),
                r = Math.abs(e) >= i,
                n = Math.abs(t) >= i;
            S && (r || n) && S(se, e, t, be, me), r && (m && 0 < se.deltaX && m(se), y && se.deltaX < 0 && y(se), _ && _(se), k && se.deltaX < 0 != le < 0 && k(se), le = se.deltaX, be[0] = be[1] = be[2] = 0), n && (w && 0 < se.deltaY && w(se), x && se.deltaY < 0 && x(se), T && T(se), E && se.deltaY < 0 != ce < 0 && E(se), ce = se.deltaY, me[0] = me[1] = me[2] = 0), (ne || re) && (I && I(se), re && (h(se), re = !1), ne = !1), oe && !(oe = !1) && $ && $(se), ie && (X(se), ie = !1), ee = 0
        }

        function ef(e, t, r) { be[r] += e, me[r] += t, se._vx.update(e), se._vy.update(t), n ? ee = ee || requestAnimationFrame(df) : df() }

        function ff(e, t) { Z && !ae && (se.axis = ae = Math.abs(e) > Math.abs(t) ? "x" : "y", oe = !0), "y" !== ae && (be[2] += e, se._vx.update(e, !0)), "x" !== ae && (me[2] += t, se._vy.update(t, !0)), n ? ee = ee || requestAnimationFrame(df) : df() }

        function gf(e) {
            if (!bf(e, 1)) {
                var t = (e = M(e, s)).clientX,
                    r = e.clientY,
                    n = t - se.x,
                    i = r - se.y,
                    o = se.isDragging;
                se.x = t, se.y = r, (o || Math.abs(se.startX - t) >= a || Math.abs(se.startY - r) >= a) && (h && (re = !0), o || (se.isDragging = !0), ff(n, i), o || p && p(se))
            }
        }

        function kf(e) { return e.touches && 1 < e.touches.length && (se.isGesturing = !0) && Y(e, se.isDragging) }

        function lf() { return (se.isGesturing = !1) || H(se) }

        function mf(e) {
            if (!bf(e)) {
                var t = ue(),
                    r = fe();
                ef((t - de) * G, (r - pe) * G, 1), de = t, pe = r, l && te.restart(!0)
            }
        }

        function nf(e) {
            if (!bf(e)) {
                e = M(e, s), X && (ie = !0);
                var t = (1 === e.deltaMode ? r : 2 === e.deltaMode ? Se.innerHeight : 1) * f;
                ef(e.deltaX * t, e.deltaY * t, 0), l && !z && te.restart(!0)
            }
        }

        function of(e) {
            if (!bf(e)) {
                var t = e.clientX,
                    r = e.clientY,
                    n = t - se.x,
                    i = r - se.y;
                se.x = t, se.y = r, ne = !0, l && te.restart(!0), (n || i) && ff(n, i)
            }
        }

        function pf(e) { se.event = e, D(se) }

        function qf(e) { se.event = e, R(se) }

        function rf(e) { return bf(e) || M(e, s) && U(se) }
        this.target = o = J(o) || ke, this.vars = e, u = u && _e.utils.toArray(u), i = i || 1e-9, a = a || 0, f = f || 1, G = G || 1, t = t || "wheel,touch,pointer", n = !1 !== n, r = r || parseFloat(Se.getComputedStyle(Pe).lineHeight) || 22;
        var ee, te, re, ne, ie, oe, ae, se = this,
            le = 0,
            ce = 0,
            ue = K(o, ze),
            fe = K(o, Ye),
            de = ue(),
            pe = fe(),
            ge = ~t.indexOf("touch") && !~t.indexOf("pointer") && "pointerdown" === De[0],
            he = A(o),
            ve = o.ownerDocument || Ce,
            be = [0, 0, 0],
            me = [0, 0, 0],
            ye = 0,
            xe = se.onPress = function(e) { bf(e, 1) || e && e.button || (se.axis = ae = null, te.pause(), se.isPressed = !0, e = M(e), le = ce = 0, se.startX = se.x = e.clientX, se.startY = se.y = e.clientY, se._vx.reset(), se._vy.reset(), B(z ? o : ve, De[1], gf, s, !0), se.deltaX = se.deltaY = 0, v && v(se)) },
            we = se.onRelease = function(t) {
                if (!bf(t, 1)) {
                    C(z ? o : ve, De[1], gf, !0);
                    var e = !isNaN(se.y - se.startY),
                        r = se.isDragging,
                        n = r && (3 < Math.abs(se.x - se.startX) || 3 < Math.abs(se.y - se.startY)),
                        i = M(t);
                    !n && e && (se._vx.reset(), se._vy.reset(), s && j && _e.delayedCall(.08, function() {
                        if (300 < qe() - ye && !t.defaultPrevented)
                            if (t.target.click) t.target.click();
                            else if (ve.createEvent) {
                            var e = ve.createEvent("MouseEvents");
                            e.initMouseEvent("click", !0, !0, Se, 1, i.screenX, i.screenY, i.clientX, i.clientY, !1, !1, !1, !1, 0, null), t.target.dispatchEvent(e)
                        }
                    })), se.isDragging = se.isGesturing = se.isPressed = !1, l && r && !z && te.restart(!0), g && r && g(se), b && b(se, n)
                }
            };
        te = se._dc = _e.delayedCall(c || .25, function onStopFunc() { se._vx.reset(), se._vy.reset(), te.pause(), l && l(se) }).pause(), se.deltaX = se.deltaY = 0, se._vx = L(0, 50, !0), se._vy = L(0, 50, !0), se.scrollX = ue, se.scrollY = fe, se.isDragging = se.isGesturing = se.isPressed = !1, Re(this), se.enable = function(e) { return se.isEnabled || (B(he ? ve : o, "scroll", F), 0 <= t.indexOf("scroll") && B(he ? ve : o, "scroll", mf, s, Q), 0 <= t.indexOf("wheel") && B(o, "wheel", nf, s, Q), (0 <= t.indexOf("touch") && Me || 0 <= t.indexOf("pointer")) && (B(o, De[0], xe, s, Q), B(ve, De[2], we), B(ve, De[3], we), j && B(o, "click", af, !1, !0), U && B(o, "click", rf), Y && B(ve, "gesturestart", kf), H && B(ve, "gestureend", lf), D && B(o, Ee + "enter", pf), R && B(o, Ee + "leave", qf), I && B(o, Ee + "move", of)), se.isEnabled = !0, e && e.type && xe(e), W && W(se)), se }, se.disable = function() { se.isEnabled && (Be.filter(function(e) { return e !== se && A(e.target) }).length || C(he ? ve : o, "scroll", F), se.isPressed && (se._vx.reset(), se._vy.reset(), C(z ? o : ve, De[1], gf, !0)), C(he ? ve : o, "scroll", mf, Q), C(o, "wheel", nf, Q), C(o, De[0], xe, Q), C(ve, De[2], we), C(ve, De[3], we), C(o, "click", af, !0), C(o, "click", rf), C(ve, "gesturestart", kf), C(ve, "gestureend", lf), C(o, Ee + "enter", pf), C(o, Ee + "leave", qf), C(o, Ee + "move", of), se.isEnabled = se.isPressed = se.isDragging = !1, V && V(se)) }, se.kill = se.revert = function() {
            se.disable();
            var e = Be.indexOf(se);
            0 <= e && Be.splice(e, 1), Ae === se && (Ae = 0)
        }, Be.push(se), z && A(o) && (Ae = se), se.enable(d)
    }, function _createClass(e, t, r) { return t && _defineProperties(e.prototype, t), r && _defineProperties(e, r), e }(Observer, [{ key: "velocityX", get: function get() { return this._vx.getVelocity() } }, { key: "velocityY", get: function get() { return this._vy.getVelocity() } }]), Observer);

    function Observer(e) { this.init(e) }
    k.version = "3.12.3", k.create = function(e) { return new k(e) }, k.register = P, k.getAll = function() { return Be.slice() }, k.getById = function(t) { return Be.filter(function(e) { return e.vars.id === t })[0] }, r() && _e.registerPlugin(k);

    function Ca(e, t, r) { var n = lt(e) && ("clamp(" === e.substr(0, 6) || -1 < e.indexOf("max")); return (r["_" + t + "Clamp"] = n) ? e.substr(6, e.length - 7) : e }

    function Da(e, t) { return !t || lt(e) && "clamp(" === e.substr(0, 6) ? e : "clamp(" + e + ")" }

    function Fa() { return Ge = 1 }

    function Ga() { return Ge = 0 }

    function Ha(e) { return e }

    function Ia(e) { return Math.round(1e5 * e) / 1e5 || 0 }

    function Ja() { return "undefined" != typeof window }

    function Ka() { return Fe || Ja() && (Fe = window.gsap) && Fe.registerPlugin && Fe }

    function La(e) { return !!~l.indexOf(e) }

    function Ma(e) { return ("Height" === e ? T : He["inner" + e]) || Xe["client" + e] || We["client" + e] }

    function Na(e) { return z(e, "getBoundingClientRect") || (La(e) ? function() { return Et.width = He.innerWidth, Et.height = T, Et } : function() { return xt(e) }) }

    function Qa(e, t) {
        var r = t.s,
            n = t.d2,
            i = t.d,
            o = t.a;
        return Math.max(0, (r = "scroll" + n) && (o = z(e, r)) ? o() - Na(e)()[i] : La(e) ? (Xe[r] || We[r]) - Ma(n) : e[r] - e["offset" + n])
    }

    function Ra(e, t) { for (var r = 0; r < g.length; r += 3) t && !~t.indexOf(g[r + 1]) || e(g[r], g[r + 1], g[r + 2]) }

    function Ta(e) { return "function" == typeof e }

    function Ua(e) { return "number" == typeof e }

    function Va(e) { return "object" == typeof e }

    function Wa(e, t, r) { return e && e.progress(t ? 0 : 1) && r && e.pause() }

    function Xa(e, t) {
        if (e.enabled) {
            var r = t(e);
            r && r.totalTime && (e.callbackAnimation = r)
        }
    }

    function mb(e) { return He.getComputedStyle(e) }

    function ob(e, t) { for (var r in t) r in e || (e[r] = t[r]); return e }

    function qb(e, t) { var r = t.d2; return e["offset" + r] || e["client" + r] || 0 }

    function rb(e) {
        var t, r = [],
            n = e.labels,
            i = e.duration();
        for (t in n) r.push(n[t] / i);
        return r
    }

    function tb(i) {
        var o = Fe.utils.snap(i),
            a = Array.isArray(i) && i.slice(0).sort(function(e, t) { return e - t });
        return a ? function(e, t, r) {
            var n;
            if (void 0 === r && (r = .001), !t) return o(e);
            if (0 < t) {
                for (e -= r, n = 0; n < a.length; n++)
                    if (a[n] >= e) return a[n];
                return a[n - 1]
            }
            for (n = a.length, e += r; n--;)
                if (a[n] <= e) return a[n];
            return a[0]
        } : function(e, t, r) { void 0 === r && (r = .001); var n = o(e); return !t || Math.abs(n - e) < r || n - e < 0 == t < 0 ? n : o(t < 0 ? e - i : e + i) }
    }

    function vb(t, r, e, n) { return e.split(",").forEach(function(e) { return t(r, e, n) }) }

    function wb(e, t, r, n, i) { return e.addEventListener(t, r, { passive: !n, capture: !!i }) }

    function xb(e, t, r, n) { return e.removeEventListener(t, r, !!n) }

    function yb(e, t, r) {
        (r = r && r.wheelHandler) && (e(t, "wheel", r), e(t, "touchmove", r))
    }

    function Cb(e, t) {
        if (lt(e)) {
            var r = e.indexOf("="),
                n = ~r ? (e.charAt(r - 1) + 1) * parseFloat(e.substr(r + 1)) : 0;
            ~r && (e.indexOf("%") > r && (n *= t / 100), e = e.substr(0, r - 1)), e = n + (e in H ? H[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0)
        }
        return e
    }

    function Db(e, t, r, n, i, o, a, s) {
        var l = i.startColor,
            c = i.endColor,
            u = i.fontSize,
            f = i.indent,
            d = i.fontWeight,
            p = Ne.createElement("div"),
            g = La(r) || "fixed" === z(r, "pinType"),
            h = -1 !== e.indexOf("scroller"),
            v = g ? We : r,
            b = -1 !== e.indexOf("start"),
            m = b ? l : c,
            y = "border-color:" + m + ";font-size:" + u + ";color:" + m + ";font-weight:" + d + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
        return y += "position:" + ((h || s) && g ? "fixed;" : "absolute;"), !h && !s && g || (y += (n === Ye ? I : q) + ":" + (o + parseFloat(f)) + "px;"), a && (y += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"), p._isStart = b, p.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), p.style.cssText = y, p.innerText = t || 0 === t ? e + "-" + t : e, v.children[0] ? v.insertBefore(p, v.children[0]) : v.appendChild(p), p._offset = p["offset" + n.op.d2], X(p, 0, n, b), p
    }

    function Ib() { return 34 < ot() - at && (D = D || requestAnimationFrame(Z)) }

    function Jb() { v && v.isPressed && !(v.startX > We.clientWidth) || (Ie.cache++, v ? D = D || requestAnimationFrame(Z) : Z(), at || U("scrollStart"), at = ot()) }

    function Kb() { y = He.innerWidth, m = He.innerHeight }

    function Lb() { Ie.cache++, Ke || h || Ne.fullscreenElement || Ne.webkitFullscreenElement || b && y === He.innerWidth && !(Math.abs(He.innerHeight - m) > .25 * He.innerHeight) || c.restart(!0) }

    function Ob() { return xb(ne, "scrollEnd", Ob) || kt(!0) }

    function Rb(e) { for (var t = 0; t < Q.length; t += 5)(!e || Q[t + 4] && Q[t + 4].query === e) && (Q[t].style.cssText = Q[t + 1], Q[t].getBBox && Q[t].setAttribute("transform", Q[t + 2] || ""), Q[t + 3].uncache = 1) }

    function Sb(e, t) {
        var r;
        for (Qe = 0; Qe < Tt.length; Qe++) !(r = Tt[Qe]) || t && r._ctx !== t || (e ? r.kill(1) : r.revert(!0, !0));
        S = !0, t && Rb(t), t || U("revert")
    }

    function Tb(e, t) { Ie.cache++, !t && tt || Ie.forEach(function(e) { return Ta(e) && e.cacheID++ && (e.rec = 0) }), lt(e) && (He.history.scrollRestoration = w = e) }

    function Yb() { We.appendChild(_), T = !v && _.offsetHeight || He.innerHeight, We.removeChild(_) }

    function fc(e, t, r, n) {
        if (!e._gsap.swappedIn) {
            for (var i, o = $.length, a = t.style, s = e.style; o--;) a[i = $[o]] = r[i];
            a.position = "absolute" === r.position ? "absolute" : "relative", "inline" === r.display && (a.display = "inline-block"), s[q] = s[I] = "auto", a.flexBasis = r.flexBasis || "auto", a.overflow = "visible", a.boxSizing = "border-box", a[ut] = qb(e, ze) + yt, a[ft] = qb(e, Ye) + yt, a[vt] = s[bt] = s.top = s.left = "0", Mt(n), s[ut] = s.maxWidth = r[ut], s[ft] = s.maxHeight = r[ft], s[vt] = r[vt], e.parentNode !== t && (e.parentNode.insertBefore(t, e), t.appendChild(e)), e._gsap.swappedIn = !0
        }
    }

    function ic(e) { for (var t = ee.length, r = e.style, n = [], i = 0; i < t; i++) n.push(ee[i], r[ee[i]]); return n.t = e, n }

    function lc(e, t, r, n, i, o, a, s, l, c, u, f, d, p) {
        Ta(e) && (e = e(s)), lt(e) && "max" === e.substr(0, 3) && (e = f + ("=" === e.charAt(4) ? Cb("0" + e.substr(3), r) : 0));
        var g, h, v, b = d ? d.time() : 0;
        if (d && d.seek(0), isNaN(e) || (e = +e), Ua(e)) d && (e = Fe.utils.mapRange(d.scrollTrigger.start, d.scrollTrigger.end, 0, f, e)), a && X(a, r, n, !0);
        else {
            Ta(t) && (t = t(s));
            var m, y, x, w, _ = (e || "0").split(" ");
            v = J(t, s) || We, (m = xt(v) || {}) && (m.left || m.top) || "none" !== mb(v).display || (w = v.style.display, v.style.display = "block", m = xt(v), w ? v.style.display = w : v.style.removeProperty("display")), y = Cb(_[0], m[n.d]), x = Cb(_[1] || "0", r), e = m[n.p] - l[n.p] - c + y + i - x, a && X(a, x, n, r - x < 20 || a._isStart && 20 < x), r -= r - x
        }
        if (p && (s[p] = e || -.001, e < 0 && (e = 0)), o) {
            var T = e + r,
                S = o._isStart;
            g = "scroll" + n.d2, X(o, T, n, S && 20 < T || !S && (u ? Math.max(We[g], Xe[g]) : o.parentNode[g]) <= T + 1), u && (l = xt(a), u && (o.style[n.op.p] = l[n.op.p] - n.op.m - o._offset + yt))
        }
        return d && v && (g = xt(v), d.seek(f), h = xt(v), d._caScrollDist = g[n.p] - h[n.p], e = e / d._caScrollDist * f), d && d.seek(b), d ? e : Math.round(e)
    }

    function nc(e, t, r, n) {
        if (e.parentNode !== t) {
            var i, o, a = e.style;
            if (t === We) {
                for (i in e._stOrig = a.cssText, o = mb(e)) + i || re.test(i) || !o[i] || "string" != typeof a[i] || "0" === i || (a[i] = o[i]);
                a.top = r, a.left = n
            } else a.cssText = e._stOrig;
            Fe.core.getCache(e).uncache = 1, t.appendChild(e)
        }
    }

    function oc(r, e, n) {
        var i = e,
            o = i;
        return function(e) { var t = Math.round(r()); return t !== i && t !== o && 3 < Math.abs(t - i) && 3 < Math.abs(t - o) && (e = t, n && n()), o = i, i = e }
    }

    function pc(e, t, r) {
        var n = {};
        n[t.p] = "+=" + r, Fe.set(e, n)
    }

    function qc(c, e) {
        function wk(e, t, r, n, i) {
            var o = wk.tween,
                a = t.onComplete,
                s = {};
            r = r || u();
            var l = oc(u, r, function() { o.kill(), wk.tween = 0 });
            return i = n && i || 0, n = n || e - r, o && o.kill(), t[f] = e, (t.modifiers = s)[f] = function() { return l(r + n * o.ratio + i * o.ratio * o.ratio) }, t.onUpdate = function() { Ie.cache++, wk.tween && Z() }, t.onComplete = function() { wk.tween = 0, a && a.call(o) }, o = wk.tween = Fe.to(c, t)
        }
        var u = K(c, e),
            f = "_scroll" + e.p2;
        return (c[f] = u).wheelHandler = function() { return wk.tween && wk.tween.kill() && (wk.tween = 0) }, wb(c, "wheel", u.wheelHandler), ne.isTouch && wb(c, "touchmove", u.wheelHandler), wk
    }
    var Fe, s, He, Ne, Xe, We, l, c, Je, Ve, Ue, u, Ke, Ge, f, Qe, d, p, g, je, Ze, h, v, b, m, y, E, x, w, _, T, S, $e, et, D, tt, rt, nt, it = 1,
        ot = Date.now,
        R = ot(),
        at = 0,
        st = 0,
        lt = function _isString(e) { return "string" == typeof e },
        ct = Math.abs,
        I = "right",
        q = "bottom",
        ut = "width",
        ft = "height",
        dt = "Right",
        pt = "Left",
        gt = "Top",
        ht = "Bottom",
        vt = "padding",
        bt = "margin",
        mt = "Width",
        Y = "Height",
        yt = "px",
        xt = function _getBounds(e, t) {
            var r = t && "matrix(1, 0, 0, 1, 0, 0)" !== mb(e)[f] && Fe.to(e, { x: 0, y: 0, xPercent: 0, yPercent: 0, rotation: 0, rotationX: 0, rotationY: 0, scale: 1, skewX: 0, skewY: 0 }).progress(1),
                n = e.getBoundingClientRect();
            return r && r.progress(0).kill(), n
        },
        wt = { startColor: "green", endColor: "red", indent: 0, fontSize: "16px", fontWeight: "normal" },
        _t = { toggleActions: "play", anticipatePin: 0 },
        H = { top: 0, left: 0, center: .5, bottom: 1, right: 1 },
        X = function _positionMarker(e, t, r, n) {
            var i = { display: "block" },
                o = r[n ? "os2" : "p2"],
                a = r[n ? "p2" : "os2"];
            e._isFlipped = n, i[r.a + "Percent"] = n ? -100 : 0, i[r.a] = n ? "1px" : 0, i["border" + o + mt] = 1, i["border" + a + mt] = 0, i[r.p] = t + "px", Fe.set(e, i)
        },
        Tt = [],
        St = {},
        W = {},
        V = [],
        U = function _dispatch(e) { return W[e] && W[e].map(function(e) { return e() }) || V },
        Q = [],
        Ct = 0,
        kt = function _refreshAll(e, t) {
            if (!at || e) {
                Yb(), tt = ne.isRefreshing = !0, Ie.forEach(function(e) { return Ta(e) && ++e.cacheID && (e.rec = e()) });
                var r = U("refreshInit");
                je && ne.sort(), t || Sb(), Ie.forEach(function(e) { Ta(e) && (e.smooth && (e.target.style.scrollBehavior = "auto"), e(0)) }), Tt.slice(0).forEach(function(e) { return e.refresh() }), S = !1, Tt.forEach(function(e) {
                    if (e._subPinOffset && e.pin) {
                        var t = e.vars.horizontal ? "offsetWidth" : "offsetHeight",
                            r = e.pin[t];
                        e.revert(!0, 1), e.adjustPinSpacing(e.pin[t] - r), e.refresh()
                    }
                }), $e = 1, Tt.forEach(function(e) {
                    var t = Qa(e.scroller, e._dir);
                    ("max" === e.vars.end || e._endClamp && e.end > t) && e.setPositions(e.start, Math.max(e.start + 1, t), !0)
                }), $e = 0, r.forEach(function(e) { return e && e.render && e.render(-1) }), Ie.forEach(function(e) { Ta(e) && (e.smooth && requestAnimationFrame(function() { return e.target.style.scrollBehavior = "smooth" }), e.rec && e(e.rec)) }), Tb(w, 1), c.pause(), Ct++, Z(tt = 2), Tt.forEach(function(e) { return Ta(e.vars.onRefresh) && e.vars.onRefresh(e) }), tt = ne.isRefreshing = !1, U("refresh")
            } else wb(ne, "scrollEnd", Ob)
        },
        j = 0,
        Pt = 1,
        Z = function _updateAll(e) {
            if (2 === e || !tt && !S) {
                ne.isUpdating = !0, nt && nt.update(0);
                var t = Tt.length,
                    r = ot(),
                    n = 50 <= r - R,
                    i = t && Tt[0].scroll();
                if (Pt = i < j ? -1 : 1, tt || (j = i), n && (at && !Ge && 200 < r - at && (at = 0, U("scrollEnd")), Ue = R, R = r), Pt < 0) {
                    for (Qe = t; 0 < Qe--;) Tt[Qe] && Tt[Qe].update(0, n);
                    Pt = 1
                } else
                    for (Qe = 0; Qe < t; Qe++) Tt[Qe] && Tt[Qe].update(0, n);
                ne.isUpdating = !1
            }
            D = 0
        },
        $ = ["left", "top", q, I, bt + ht, bt + dt, bt + gt, bt + pt, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
        ee = $.concat([ut, ft, "boxSizing", "max" + mt, "max" + Y, "position", bt, vt, vt + gt, vt + dt, vt + ht, vt + pt]),
        te = /([A-Z])/g,
        Mt = function _setState(e) {
            if (e) {
                var t, r, n = e.t.style,
                    i = e.length,
                    o = 0;
                for ((e.t._gsap || Fe.core.getCache(e.t)).uncache = 1; o < i; o += 2) r = e[o + 1], t = e[o], r ? n[t] = r : n[t] && n.removeProperty(t.replace(te, "-$1").toLowerCase())
            }
        },
        Et = { left: 0, top: 0 },
        re = /(webkit|moz|length|cssText|inset)/i,
        ne = (ScrollTrigger.prototype.init = function init(E, O) {
            if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), st) {
                var A, n, p, D, R, B, I, L, q, Y, F, e, H, N, X, W, V, U, t, G, b, Q, j, m, Z, y, $, x, r, w, _, ee, i, g, te, re, ne, T, o, S = (E = ob(lt(E) || Ua(E) || E.nodeType ? { trigger: E } : E, _t)).onUpdate,
                    C = E.toggleClass,
                    a = E.id,
                    k = E.onToggle,
                    ie = E.onRefresh,
                    P = E.scrub,
                    oe = E.trigger,
                    ae = E.pin,
                    se = E.pinSpacing,
                    le = E.invalidateOnRefresh,
                    M = E.anticipatePin,
                    s = E.onScrubComplete,
                    h = E.onSnapComplete,
                    ce = E.once,
                    ue = E.snap,
                    fe = E.pinReparent,
                    l = E.pinSpacer,
                    de = E.containerAnimation,
                    pe = E.fastScrollEnd,
                    ge = E.preventOverlaps,
                    he = E.horizontal || E.containerAnimation && !1 !== E.horizontal ? ze : Ye,
                    ve = !P && 0 !== P,
                    be = J(E.scroller || He),
                    c = Fe.core.getCache(be),
                    me = La(be),
                    ye = "fixed" === ("pinType" in E ? E.pinType : z(be, "pinType") || me && "fixed"),
                    xe = [E.onEnter, E.onLeave, E.onEnterBack, E.onLeaveBack],
                    we = ve && E.toggleActions.split(" "),
                    _e = "markers" in E ? E.markers : _t.markers,
                    Te = me ? 0 : parseFloat(mb(be)["border" + he.p2 + mt]) || 0,
                    Se = this,
                    Ce = E.onRefreshInit && function() { return E.onRefreshInit(Se) },
                    ke = function _getSizeFunc(e, t, r) {
                        var n = r.d,
                            i = r.d2,
                            o = r.a;
                        return (o = z(e, "getBoundingClientRect")) ? function() { return o()[n] } : function() { return (t ? Ma(i) : e["client" + i]) || 0 }
                    }(be, me, he),
                    Pe = function _getOffsetsFunc(e, t) { return !t || ~Le.indexOf(e) ? Na(e) : function() { return Et } }(be, me),
                    Me = 0,
                    Ee = 0,
                    Oe = 0,
                    Ae = K(be, he);
                if (Se._startClamp = Se._endClamp = !1, Se._dir = he, M *= 45, Se.scroller = be, Se.scroll = de ? de.time.bind(de) : Ae, D = Ae(), Se.vars = E, O = O || E.animation, "refreshPriority" in E && (je = 1, -9999 === E.refreshPriority && (nt = Se)), c.tweenScroll = c.tweenScroll || { top: qc(be, Ye), left: qc(be, ze) }, Se.tweenTo = A = c.tweenScroll[he.p], Se.scrubDuration = function(e) {
                        (i = Ua(e) && e) ? ee ? ee.duration(e) : ee = Fe.to(O, { ease: "expo", totalProgress: "+=0", duration: i, paused: !0, onComplete: function onComplete() { return s && s(Se) } }): (ee && ee.progress(1).kill(), ee = 0)
                    }, O && (O.vars.lazy = !1, O._initted && !Se.isReverted || !1 !== O.vars.immediateRender && !1 !== E.immediateRender && O.duration() && O.render(0, !0, !0), Se.animation = O.pause(), (O.scrollTrigger = Se).scrubDuration(P), w = 0, a = a || O.vars.id), ue && (Va(ue) && !ue.push || (ue = { snapTo: ue }), "scrollBehavior" in We.style && Fe.set(me ? [We, Xe] : be, { scrollBehavior: "auto" }), Ie.forEach(function(e) { return Ta(e) && e.target === (me ? Ne.scrollingElement || Xe : be) && (e.smooth = !1) }), p = Ta(ue.snapTo) ? ue.snapTo : "labels" === ue.snapTo ? function _getClosestLabel(t) { return function(e) { return Fe.utils.snap(rb(t), e) } }(O) : "labelsDirectional" === ue.snapTo ? function _getLabelAtDirection(r) { return function(e, t) { return tb(rb(r))(e, t.direction) } }(O) : !1 !== ue.directional ? function(e, t) { return tb(ue.snapTo)(e, ot() - Ee < 500 ? 0 : t.direction) } : Fe.utils.snap(ue.snapTo), g = ue.duration || { min: .1, max: 2 }, g = Va(g) ? Ve(g.min, g.max) : Ve(g, g), te = Fe.delayedCall(ue.delay || i / 2 || .1, function() {
                        var e = Ae(),
                            t = ot() - Ee < 500,
                            r = A.tween;
                        if (!(t || Math.abs(Se.getVelocity()) < 10) || r || Ge || Me === e) Se.isActive && Me !== e && te.restart(!0);
                        else {
                            var n = (e - B) / N,
                                i = O && !ve ? O.totalProgress() : n,
                                o = t ? 0 : (i - _) / (ot() - Ue) * 1e3 || 0,
                                a = Fe.utils.clamp(-n, 1 - n, ct(o / 2) * o / .185),
                                s = n + (!1 === ue.inertia ? 0 : a),
                                l = Ve(0, 1, p(s, Se)),
                                c = Math.round(B + l * N),
                                u = ue.onStart,
                                f = ue.onInterrupt,
                                d = ue.onComplete;
                            if (e <= I && B <= e && c !== e) { if (r && !r._initted && r.data <= ct(c - e)) return;!1 === ue.inertia && (a = l - n), A(c, { duration: g(ct(.185 * Math.max(ct(s - i), ct(l - i)) / o / .05 || 0)), ease: ue.ease || "power3", data: ct(c - e), onInterrupt: function onInterrupt() { return te.restart(!0) && f && f(Se) }, onComplete: function onComplete() { Se.update(), Me = Ae(), w = _ = O && !ve ? O.totalProgress() : Se.progress, h && h(Se), d && d(Se) } }, e, a * N, c - e - a * N), u && u(Se, A.tween) }
                        }
                    }).pause()), a && (St[a] = Se), o = (o = (oe = Se.trigger = J(oe || !0 !== ae && ae)) && oe._gsap && oe._gsap.stRevert) && o(Se), ae = !0 === ae ? oe : J(ae), lt(C) && (C = { targets: oe, className: C }), ae && (!1 === se || se === bt || (se = !(!se && ae.parentNode && ae.parentNode.style && "flex" === mb(ae.parentNode).display) && vt), Se.pin = ae, (n = Fe.core.getCache(ae)).spacer ? X = n.pinState : (l && ((l = J(l)) && !l.nodeType && (l = l.current || l.nativeElement), n.spacerIsNative = !!l, l && (n.spacerState = ic(l))), n.spacer = U = l || Ne.createElement("div"), U.classList.add("pin-spacer"), a && U.classList.add("pin-spacer-" + a), n.pinState = X = ic(ae)), !1 !== E.force3D && Fe.set(ae, { force3D: !0 }), Se.spacer = U = n.spacer, r = mb(ae), m = r[se + he.os2], G = Fe.getProperty(ae), b = Fe.quickSetter(ae, he.a, yt), fc(ae, U, r), V = ic(ae)), _e) {
                    e = Va(_e) ? ob(_e, wt) : wt, Y = Db("scroller-start", a, be, he, e, 0), F = Db("scroller-end", a, be, he, e, 0, Y), t = Y["offset" + he.op.d2];
                    var u = J(z(be, "content") || be);
                    L = this.markerStart = Db("start", a, u, he, e, t, 0, de), q = this.markerEnd = Db("end", a, u, he, e, t, 0, de), de && (T = Fe.quickSetter([L, q], he.a, yt)), ye || Le.length && !0 === z(be, "fixedMarkers") || (function _makePositionable(e) {
                        var t = mb(e).position;
                        e.style.position = "absolute" === t || "fixed" === t ? t : "relative"
                    }(me ? We : be), Fe.set([Y, F], { force3D: !0 }), y = Fe.quickSetter(Y, he.a, yt), x = Fe.quickSetter(F, he.a, yt))
                }
                if (de) {
                    var f = de.vars.onUpdate,
                        d = de.vars.onUpdateParams;
                    de.eventCallback("onUpdate", function() { Se.update(0, 0, 1), f && f.apply(de, d || []) })
                }
                if (Se.previous = function() { return Tt[Tt.indexOf(Se) - 1] }, Se.next = function() { return Tt[Tt.indexOf(Se) + 1] }, Se.revert = function(e, t) {
                        if (!t) return Se.kill(!0);
                        var r = !1 !== e || !Se.enabled,
                            n = Ke;
                        r !== Se.isReverted && (r && (re = Math.max(Ae(), Se.scroll.rec || 0), Oe = Se.progress, ne = O && O.progress()), L && [L, q, Y, F].forEach(function(e) { return e.style.display = r ? "none" : "block" }), r && (Ke = Se).update(r), !ae || fe && Se.isActive || (r ? function _swapPinOut(e, t, r) {
                            Mt(r);
                            var n = e._gsap;
                            if (n.spacerIsNative) Mt(n.spacerState);
                            else if (e._gsap.swappedIn) {
                                var i = t.parentNode;
                                i && (i.insertBefore(e, t), i.removeChild(t))
                            }
                            e._gsap.swappedIn = !1
                        }(ae, U, X) : fc(ae, U, mb(ae), Z)), r || Se.update(r), Ke = n, Se.isReverted = r)
                    }, Se.refresh = function(e, t, r, n) {
                        if (!Ke && Se.enabled || t)
                            if (ae && e && at) wb(ScrollTrigger, "scrollEnd", Ob);
                            else {
                                !tt && Ce && Ce(Se), Ke = Se, A.tween && !r && (A.tween.kill(), A.tween = 0), ee && ee.pause(), le && O && O.revert({ kill: !1 }).invalidate(), Se.isReverted || Se.revert(!0, !0), Se._subPinOffset = !1;
                                var i, o, a, s, l, c, u, f, d, p, g, h, v, b = ke(),
                                    m = Pe(),
                                    y = de ? de.duration() : Qa(be, he),
                                    x = N <= .01,
                                    w = 0,
                                    _ = n || 0,
                                    T = Va(r) ? r.end : E.end,
                                    S = E.endTrigger || oe,
                                    C = Va(r) ? r.start : E.start || (0 !== E.start && oe ? ae ? "0 0" : "0 100%" : 0),
                                    k = Se.pinnedContainer = E.pinnedContainer && J(E.pinnedContainer, Se),
                                    P = oe && Math.max(0, Tt.indexOf(Se)) || 0,
                                    M = P;
                                for (_e && Va(r) && (h = Fe.getProperty(Y, he.p), v = Fe.getProperty(F, he.p)); M--;)(c = Tt[M]).end || c.refresh(0, 1) || (Ke = Se), !(u = c.pin) || u !== oe && u !== ae && u !== k || c.isReverted || ((p = p || []).unshift(c), c.revert(!0, !0)), c !== Tt[M] && (P--, M--);
                                for (Ta(C) && (C = C(Se)), C = Ca(C, "start", Se), B = lc(C, oe, b, he, Ae(), L, Y, Se, m, Te, ye, y, de, Se._startClamp && "_startClamp") || (ae ? -.001 : 0), Ta(T) && (T = T(Se)), lt(T) && !T.indexOf("+=") && (~T.indexOf(" ") ? T = (lt(C) ? C.split(" ")[0] : "") + T : (w = Cb(T.substr(2), b), T = lt(C) ? C : (de ? Fe.utils.mapRange(0, de.duration(), de.scrollTrigger.start, de.scrollTrigger.end, B) : B) + w, S = oe)), T = Ca(T, "end", Se), I = Math.max(B, lc(T || (S ? "100% 0" : y), S, b, he, Ae() + w, q, F, Se, m, Te, ye, y, de, Se._endClamp && "_endClamp")) || -.001, w = 0, M = P; M--;)(u = (c = Tt[M]).pin) && c.start - c._pinPush <= B && !de && 0 < c.end && (i = c.end - (Se._startClamp ? Math.max(0, c.start) : c.start), (u === oe && c.start - c._pinPush < B || u === k) && isNaN(C) && (w += i * (1 - c.progress)), u === ae && (_ += i));
                                if (B += w, I += w, Se._startClamp && (Se._startClamp += w), Se._endClamp && !tt && (Se._endClamp = I || -.001, I = Math.min(I, Qa(be, he))), N = I - B || (B -= .01) && .001, x && (Oe = Fe.utils.clamp(0, 1, Fe.utils.normalize(B, I, re))), Se._pinPush = _, L && w && ((i = {})[he.a] = "+=" + w, k && (i[he.p] = "-=" + Ae()), Fe.set([L, q], i)), !ae || $e && Se.end >= Qa(be, he)) {
                                    if (oe && Ae() && !de)
                                        for (o = oe.parentNode; o && o !== We;) o._pinOffset && (B -= o._pinOffset, I -= o._pinOffset), o = o.parentNode
                                } else i = mb(ae), s = he === Ye, a = Ae(), Q = parseFloat(G(he.a)) + _, !y && 1 < I && (g = { style: g = (me ? Ne.scrollingElement || Xe : be).style, value: g["overflow" + he.a.toUpperCase()] }, me && "scroll" !== mb(We)["overflow" + he.a.toUpperCase()] && (g.style["overflow" + he.a.toUpperCase()] = "scroll")), fc(ae, U, i), V = ic(ae), o = xt(ae, !0), f = ye && K(be, s ? ze : Ye)(), se && ((Z = [se + he.os2, N + _ + yt]).t = U, (M = se === vt ? qb(ae, he) + N + _ : 0) && Z.push(he.d, M + yt), Mt(Z), k && Tt.forEach(function(e) { e.pin === k && !1 !== e.vars.pinSpacing && (e._subPinOffset = !0) }), ye && Ae(re)), ye && ((l = { top: o.top + (s ? a - B : f) + yt, left: o.left + (s ? f : a - B) + yt, boxSizing: "border-box", position: "fixed" })[ut] = l.maxWidth = Math.ceil(o.width) + yt, l[ft] = l.maxHeight = Math.ceil(o.height) + yt, l[bt] = l[bt + gt] = l[bt + dt] = l[bt + ht] = l[bt + pt] = "0", l[vt] = i[vt], l[vt + gt] = i[vt + gt], l[vt + dt] = i[vt + dt], l[vt + ht] = i[vt + ht], l[vt + pt] = i[vt + pt], W = function _copyState(e, t, r) { for (var n, i = [], o = e.length, a = r ? 8 : 0; a < o; a += 2) n = e[a], i.push(n, n in t ? t[n] : e[a + 1]); return i.t = e.t, i }(X, l, fe), tt && Ae(0)), O ? (d = O._initted, Ze(1), O.render(O.duration(), !0, !0), j = G(he.a) - Q + N + _, $ = 1 < Math.abs(N - j), ye && $ && W.splice(W.length - 2, 2), O.render(0, !0, !0), d || O.invalidate(!0), O.parent || O.totalTime(O.totalTime()), Ze(0)) : j = N, g && (g.value ? g.style["overflow" + he.a.toUpperCase()] = g.value : g.style.removeProperty("overflow-" + he.a));
                                p && p.forEach(function(e) { return e.revert(!1, !0) }), Se.start = B, Se.end = I, D = R = tt ? re : Ae(), de || tt || (D < re && Ae(re), Se.scroll.rec = 0), Se.revert(!1, !0), Ee = ot(), te && (Me = -1, te.restart(!0)), Ke = 0, O && ve && (O._initted || ne) && O.progress() !== ne && O.progress(ne || 0, !0).render(O.time(), !0, !0), (x || Oe !== Se.progress || de) && (O && !ve && O.totalProgress(de && B < -.001 && !Oe ? Fe.utils.normalize(B, I, 0) : Oe, !0), Se.progress = x || (D - B) / N === Oe ? 0 : Oe), ae && se && (U._pinOffset = Math.round(Se.progress * j)), ee && ee.invalidate(), isNaN(h) || (h -= Fe.getProperty(Y, he.p), v -= Fe.getProperty(F, he.p), pc(Y, he, h), pc(L, he, h - (n || 0)), pc(F, he, v), pc(q, he, v - (n || 0))), x && !tt && Se.update(), !ie || tt || H || (H = !0, ie(Se), H = !1)
                            }
                    }, Se.getVelocity = function() { return (Ae() - R) / (ot() - Ue) * 1e3 || 0 }, Se.endAnimation = function() { Wa(Se.callbackAnimation), O && (ee ? ee.progress(1) : O.paused() ? ve || Wa(O, Se.direction < 0, 1) : Wa(O, O.reversed())) }, Se.labelToScroll = function(e) { return O && O.labels && (B || Se.refresh() || B) + O.labels[e] / O.duration() * N || 0 }, Se.getTrailing = function(t) {
                        var e = Tt.indexOf(Se),
                            r = 0 < Se.direction ? Tt.slice(0, e).reverse() : Tt.slice(e + 1);
                        return (lt(t) ? r.filter(function(e) { return e.vars.preventOverlaps === t }) : r).filter(function(e) { return 0 < Se.direction ? e.end <= B : e.start >= I })
                    }, Se.update = function(e, t, r) {
                        if (!de || r || e) {
                            var n, i, o, a, s, l, c, u = !0 === tt ? re : Se.scroll(),
                                f = e ? 0 : (u - B) / N,
                                d = f < 0 ? 0 : 1 < f ? 1 : f || 0,
                                p = Se.progress;
                            if (t && (R = D, D = de ? Ae() : u, ue && (_ = w, w = O && !ve ? O.totalProgress() : d)), M && !d && ae && !Ke && !it && at && B < u + (u - R) / (ot() - Ue) * M && (d = 1e-4), d !== p && Se.enabled) {
                                if (a = (s = (n = Se.isActive = !!d && d < 1) != (!!p && p < 1)) || !!d != !!p, Se.direction = p < d ? 1 : -1, Se.progress = d, a && !Ke && (i = d && !p ? 0 : 1 === d ? 1 : 1 === p ? 2 : 3, ve && (o = !s && "none" !== we[i + 1] && we[i + 1] || we[i], c = O && ("complete" === o || "reset" === o || o in O))), ge && (s || c) && (c || P || !O) && (Ta(ge) ? ge(Se) : Se.getTrailing(ge).forEach(function(e) { return e.endAnimation() })), ve || (!ee || Ke || it ? O && O.totalProgress(d, !(!Ke || !Ee && !e)) : (ee._dp._time - ee._start !== ee._time && ee.render(ee._dp._time - ee._start), ee.resetTo ? ee.resetTo("totalProgress", d, O._tTime / O._tDur) : (ee.vars.totalProgress = d, ee.invalidate().restart()))), ae)
                                    if (e && se && (U.style[se + he.os2] = m), ye) {
                                        if (a) {
                                            if (l = !e && p < d && u < I + 1 && u + 1 >= Qa(be, he), fe)
                                                if (e || !n && !l) nc(ae, U);
                                                else {
                                                    var g = xt(ae, !0),
                                                        h = u - B;
                                                    nc(ae, We, g.top + (he === Ye ? h : 0) + yt, g.left + (he === Ye ? 0 : h) + yt)
                                                }
                                            Mt(n || l ? W : V), $ && d < 1 && n || b(Q + (1 !== d || l ? 0 : j))
                                        }
                                    } else b(Ia(Q + j * d));
                                    !ue || A.tween || Ke || it || te.restart(!0), C && (s || ce && d && (d < 1 || !et)) && Je(C.targets).forEach(function(e) { return e.classList[n || ce ? "add" : "remove"](C.className) }), !S || ve || e || S(Se), a && !Ke ? (ve && (c && ("complete" === o ? O.pause().totalProgress(1) : "reset" === o ? O.restart(!0).pause() : "restart" === o ? O.restart(!0) : O[o]()), S && S(Se)), !s && et || (k && s && Xa(Se, k), xe[i] && Xa(Se, xe[i]), ce && (1 === d ? Se.kill(!1, 1) : xe[i] = 0), s || xe[i = 1 === d ? 1 : 3] && Xa(Se, xe[i])), pe && !n && Math.abs(Se.getVelocity()) > (Ua(pe) ? pe : 2500) && (Wa(Se.callbackAnimation), ee ? ee.progress(1) : Wa(O, "reverse" === o ? 1 : !d, 1))) : ve && S && !Ke && S(Se)
                            }
                            if (x) {
                                var v = de ? u / de.duration() * (de._caScrollDist || 0) : u;
                                y(v + (Y._isFlipped ? 1 : 0)), x(v)
                            }
                            T && T(-u / de.duration() * (de._caScrollDist || 0))
                        }
                    }, Se.enable = function(e, t) { Se.enabled || (Se.enabled = !0, wb(be, "resize", Lb), me || wb(be, "scroll", Jb), Ce && wb(ScrollTrigger, "refreshInit", Ce), !1 !== e && (Se.progress = Oe = 0, D = R = Me = Ae()), !1 !== t && Se.refresh()) }, Se.getTween = function(e) { return e && A ? A.tween : ee }, Se.setPositions = function(e, t, r, n) {
                        if (de) {
                            var i = de.scrollTrigger,
                                o = de.duration(),
                                a = i.end - i.start;
                            e = i.start + a * e / o, t = i.start + a * t / o
                        }
                        Se.refresh(!1, !1, { start: Da(e, r && !!Se._startClamp), end: Da(t, r && !!Se._endClamp) }, n), Se.update()
                    }, Se.adjustPinSpacing = function(e) {
                        if (Z && e) {
                            var t = Z.indexOf(he.d) + 1;
                            Z[t] = parseFloat(Z[t]) + e + yt, Z[1] = parseFloat(Z[1]) + e + yt, Mt(Z)
                        }
                    }, Se.disable = function(e, t) {
                        if (Se.enabled && (!1 !== e && Se.revert(!0, !0), Se.enabled = Se.isActive = !1, t || ee && ee.pause(), re = 0, n && (n.uncache = 1), Ce && xb(ScrollTrigger, "refreshInit", Ce), te && (te.pause(), A.tween && A.tween.kill() && (A.tween = 0)), !me)) {
                            for (var r = Tt.length; r--;)
                                if (Tt[r].scroller === be && Tt[r] !== Se) return;
                            xb(be, "resize", Lb), me || xb(be, "scroll", Jb)
                        }
                    }, Se.kill = function(e, t) {
                        Se.disable(e, t), ee && !t && ee.kill(), a && delete St[a];
                        var r = Tt.indexOf(Se);
                        0 <= r && Tt.splice(r, 1), r === Qe && 0 < Pt && Qe--, r = 0, Tt.forEach(function(e) { return e.scroller === Se.scroller && (r = 1) }), r || tt || (Se.scroll.rec = 0), O && (O.scrollTrigger = null, e && O.revert({ kill: !1 }), t || O.kill()), L && [L, q, Y, F].forEach(function(e) { return e.parentNode && e.parentNode.removeChild(e) }), nt === Se && (nt = 0), ae && (n && (n.uncache = 1), r = 0, Tt.forEach(function(e) { return e.pin === ae && r++ }), r || (n.spacer = 0)), E.onKill && E.onKill(Se)
                    }, Tt.push(Se), Se.enable(!1, !1), o && o(Se), O && O.add && !N) {
                    var v = Se.update;
                    Se.update = function() { Se.update = v, B || I || Se.refresh() }, Fe.delayedCall(.01, Se.update), N = .01, B = I = 0
                } else Se.refresh();
                ae && function _queueRefreshAll() {
                    if (rt !== Ct) {
                        var e = rt = Ct;
                        requestAnimationFrame(function() { return e === Ct && kt(!0) })
                    }
                }()
            } else this.update = this.refresh = this.kill = Ha
        }, ScrollTrigger.register = function register(e) { return s || (Fe = e || Ka(), Ja() && window.document && ScrollTrigger.enable(), s = st), s }, ScrollTrigger.defaults = function defaults(e) {
            if (e)
                for (var t in e) _t[t] = e[t];
            return _t
        }, ScrollTrigger.disable = function disable(t, r) { st = 0, Tt.forEach(function(e) { return e[r ? "kill" : "disable"](t) }), xb(He, "wheel", Jb), xb(Ne, "scroll", Jb), clearInterval(u), xb(Ne, "touchcancel", Ha), xb(We, "touchstart", Ha), vb(xb, Ne, "pointerdown,touchstart,mousedown", Fa), vb(xb, Ne, "pointerup,touchend,mouseup", Ga), c.kill(), Ra(xb); for (var e = 0; e < Ie.length; e += 3) yb(xb, Ie[e], Ie[e + 1]), yb(xb, Ie[e], Ie[e + 2]) }, ScrollTrigger.enable = function enable() {
            if (He = window, Ne = document, Xe = Ne.documentElement, We = Ne.body, Fe && (Je = Fe.utils.toArray, Ve = Fe.utils.clamp, x = Fe.core.context || Ha, Ze = Fe.core.suppressOverwrites || Ha, w = He.history.scrollRestoration || "auto", j = He.pageYOffset, Fe.core.globals("ScrollTrigger", ScrollTrigger), We)) {
                st = 1, (_ = document.createElement("div")).style.height = "100vh", _.style.position = "absolute", Yb(),
                    function _rafBugFix() { return st && requestAnimationFrame(_rafBugFix) }(), k.register(Fe), ScrollTrigger.isTouch = k.isTouch, E = k.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), wb(He, "wheel", Jb), l = [He, Ne, Xe, We], Fe.matchMedia ? (ScrollTrigger.matchMedia = function(e) { var t, r = Fe.matchMedia(); for (t in e) r.add(t, e[t]); return r }, Fe.addEventListener("matchMediaInit", function() { return Sb() }), Fe.addEventListener("matchMediaRevert", function() { return Rb() }), Fe.addEventListener("matchMedia", function() { kt(0, 1), U("matchMedia") }), Fe.matchMedia("(orientation: portrait)", function() { return Kb(), Kb })) : console.warn("Requires GSAP 3.11.0 or later"), Kb(), wb(Ne, "scroll", Jb);
                var e, t, r = We.style,
                    n = r.borderTopStyle,
                    i = Fe.core.Animation.prototype;
                for (i.revert || Object.defineProperty(i, "revert", { value: function value() { return this.time(-.01, !0) } }), r.borderTopStyle = "solid", e = xt(We), Ye.m = Math.round(e.top + Ye.sc()) || 0, ze.m = Math.round(e.left + ze.sc()) || 0, n ? r.borderTopStyle = n : r.removeProperty("border-top-style"), u = setInterval(Ib, 250), Fe.delayedCall(.5, function() { return it = 0 }), wb(Ne, "touchcancel", Ha), wb(We, "touchstart", Ha), vb(wb, Ne, "pointerdown,touchstart,mousedown", Fa), vb(wb, Ne, "pointerup,touchend,mouseup", Ga), f = Fe.utils.checkPrefix("transform"), ee.push(f), s = ot(), c = Fe.delayedCall(.2, kt).pause(), g = [Ne, "visibilitychange", function() {
                        var e = He.innerWidth,
                            t = He.innerHeight;
                        Ne.hidden ? (d = e, p = t) : d === e && p === t || Lb()
                    }, Ne, "DOMContentLoaded", kt, He, "load", kt, He, "resize", Lb], Ra(wb), Tt.forEach(function(e) { return e.enable(0, 1) }), t = 0; t < Ie.length; t += 3) yb(xb, Ie[t], Ie[t + 1]), yb(xb, Ie[t], Ie[t + 2])
            }
        }, ScrollTrigger.config = function config(e) {
            "limitCallbacks" in e && (et = !!e.limitCallbacks);
            var t = e.syncInterval;
            t && clearInterval(u) || (u = t) && setInterval(Ib, t), "ignoreMobileResize" in e && (b = 1 === ScrollTrigger.isTouch && e.ignoreMobileResize), "autoRefreshEvents" in e && (Ra(xb) || Ra(wb, e.autoRefreshEvents || "none"), h = -1 === (e.autoRefreshEvents + "").indexOf("resize"))
        }, ScrollTrigger.scrollerProxy = function scrollerProxy(e, t) {
            var r = J(e),
                n = Ie.indexOf(r),
                i = La(r);
            ~n && Ie.splice(n, i ? 6 : 2), t && (i ? Le.unshift(He, t, We, t, Xe, t) : Le.unshift(r, t))
        }, ScrollTrigger.clearMatchMedia = function clearMatchMedia(t) { Tt.forEach(function(e) { return e._ctx && e._ctx.query === t && e._ctx.kill(!0, !0) }) }, ScrollTrigger.isInViewport = function isInViewport(e, t, r) {
            var n = (lt(e) ? J(e) : e).getBoundingClientRect(),
                i = n[r ? ut : ft] * t || 0;
            return r ? 0 < n.right - i && n.left + i < He.innerWidth : 0 < n.bottom - i && n.top + i < He.innerHeight
        }, ScrollTrigger.positionInViewport = function positionInViewport(e, t, r) {
            lt(e) && (e = J(e));
            var n = e.getBoundingClientRect(),
                i = n[r ? ut : ft],
                o = null == t ? i / 2 : t in H ? H[t] * i : ~t.indexOf("%") ? parseFloat(t) * i / 100 : parseFloat(t) || 0;
            return r ? (n.left + o) / He.innerWidth : (n.top + o) / He.innerHeight
        }, ScrollTrigger.killAll = function killAll(e) {
            if (Tt.slice(0).forEach(function(e) { return "ScrollSmoother" !== e.vars.id && e.kill() }), !0 !== e) {
                var t = W.killAll || [];
                W = {}, t.forEach(function(e) { return e() })
            }
        }, ScrollTrigger);

    function ScrollTrigger(e, t) { s || ScrollTrigger.register(Fe) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), x(this), this.init(e, t) }
    ne.version = "3.12.3", ne.saveStyles = function(e) {
        return e ? Je(e).forEach(function(e) {
            if (e && e.style) {
                var t = Q.indexOf(e);
                0 <= t && Q.splice(t, 5), Q.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), Fe.core.getCache(e), x())
            }
        }) : Q
    }, ne.revert = function(e, t) { return Sb(!e, t) }, ne.create = function(e, t) { return new ne(e, t) }, ne.refresh = function(e) { return e ? Lb() : (s || ne.register()) && kt(!0) }, ne.update = function(e) { return ++Ie.cache && Z(!0 === e ? 2 : 0) }, ne.clearScrollMemory = Tb, ne.maxScroll = function(e, t) { return Qa(e, t ? ze : Ye) }, ne.getScrollFunc = function(e, t) { return K(J(e), t ? ze : Ye) }, ne.getById = function(e) { return St[e] }, ne.getAll = function() { return Tt.filter(function(e) { return "ScrollSmoother" !== e.vars.id }) }, ne.isScrolling = function() { return !!at }, ne.snapDirectional = tb, ne.addEventListener = function(e, t) { var r = W[e] || (W[e] = []);~r.indexOf(t) || r.push(t) }, ne.removeEventListener = function(e, t) {
        var r = W[e],
            n = r && r.indexOf(t);
        0 <= n && r.splice(n, 1)
    }, ne.batch = function(e, t) {
        function wp(e, t) {
            var r = [],
                n = [],
                i = Fe.delayedCall(o, function() { t(r, n), r = [], n = [] }).pause();
            return function(e) { r.length || i.restart(!0), r.push(e.trigger), n.push(e), a <= r.length && i.progress(1) }
        }
        var r, n = [],
            i = {},
            o = t.interval || .016,
            a = t.batchMax || 1e9;
        for (r in t) i[r] = "on" === r.substr(0, 2) && Ta(t[r]) && "onRefreshInit" !== r ? wp(0, t[r]) : t[r];
        return Ta(a) && (a = a(), wb(ne, "refresh", function() { return a = t.batchMax() })), Je(e).forEach(function(e) {
            var t = {};
            for (r in i) t[r] = i[r];
            t.trigger = e, n.push(ne.create(t))
        }), n
    };

    function sc(e, t, r, n) { return n < t ? e(n) : t < 0 && e(0), n < r ? (n - t) / (r - t) : r < 0 ? t / (t - r) : 1 }

    function tc(e, t) {!0 === t ? e.style.removeProperty("touch-action") : e.style.touchAction = !0 === t ? "auto" : t ? "pan-" + t + (k.isTouch ? " pinch-zoom" : "") : "none", e === Xe && tc(We, t) }

    function vc(e) {
        var t, r = e.event,
            n = e.target,
            i = e.axis,
            o = (r.changedTouches ? r.changedTouches[0] : r).target,
            a = o._gsap || Fe.core.getCache(o),
            s = ot();
        if (!a._isScrollT || 2e3 < s - a._isScrollT) {
            for (; o && o !== We && (o.scrollHeight <= o.clientHeight && o.scrollWidth <= o.clientWidth || !oe[(t = mb(o)).overflowY] && !oe[t.overflowX]);) o = o.parentNode;
            a._isScroll = o && o !== n && !La(o) && (oe[(t = mb(o)).overflowY] || oe[t.overflowX]), a._isScrollT = s
        }!a._isScroll && "x" !== i || (r.stopPropagation(), r._gsapAllow = !0)
    }

    function wc(e, t, r, n) { return k.create({ target: e, capture: !0, debounce: !1, lockAxis: !0, type: t, onWheel: n = n && vc, onPress: n, onDrag: n, onScroll: n, onEnable: function onEnable() { return r && wb(Ne, k.eventTypes[0], se, !1, !0) }, onDisable: function onDisable() { return xb(Ne, k.eventTypes[0], se, !0) } }) }

    function Ac(e) {
        function tq() { return i = !1 }

        function wq() { o = Qa(p, Ye), C = Ve(E ? 1 : 0, o), f && (S = Ve(0, Qa(p, ze))), l = Ct }

        function xq() { v._gsap.y = Ia(parseFloat(v._gsap.y) + b.offset) + "px", v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(v._gsap.y) + ", 0, 1)", b.offset = b.cacheID = 0 }

        function Dq() { wq(), a.isActive() && a.vars.scrollY > o && (b() > o ? a.progress(1) && b(o) : a.resetTo("scrollY", o)) }
        Va(e) || (e = {}), e.preventDefault = e.isNormalizer = e.allowClicks = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer";
        var n, o, l, i, a, c, u, s, f = e.normalizeScrollX,
            t = e.momentum,
            r = e.allowNestedScroll,
            d = e.onRelease,
            p = J(e.target) || Xe,
            g = Fe.core.globals().ScrollSmoother,
            h = g && g.get(),
            v = E && (e.content && J(e.content) || h && !1 !== e.content && !h.smooth() && h.content()),
            b = K(p, Ye),
            m = K(p, ze),
            y = 1,
            x = (k.isTouch && He.visualViewport ? He.visualViewport.scale * He.visualViewport.width : He.outerWidth) / He.innerWidth,
            w = 0,
            _ = Ta(t) ? function() { return t(n) } : function() { return t || 2.8 },
            T = wc(p, e.type, !0, r),
            S = Ha,
            C = Ha;
        return v && Fe.set(v, { y: "+=0" }), e.ignoreCheck = function(e) {
            return E && "touchmove" === e.type && function ignoreDrag() {
                if (i) {
                    requestAnimationFrame(tq);
                    var e = Ia(n.deltaY / 2),
                        t = C(b.v - e);
                    if (v && t !== b.v + b.offset) {
                        b.offset = t - b.v;
                        var r = Ia((parseFloat(v && v._gsap.y) || 0) - b.offset);
                        v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + r + ", 0, 1)", v._gsap.y = r + "px", b.cacheID = Ie.cache, Z()
                    }
                    return !0
                }
                b.offset && xq(), i = !0
            }() || 1.05 < y && "touchstart" !== e.type || n.isGesturing || e.touches && 1 < e.touches.length
        }, e.onPress = function() {
            i = !1;
            var e = y;
            y = Ia((He.visualViewport && He.visualViewport.scale || 1) / x), a.pause(), e !== y && tc(p, 1.01 < y || !f && "x"), c = m(), u = b(), wq(), l = Ct
        }, e.onRelease = e.onGestureStart = function(e, t) {
            if (b.offset && xq(), t) {
                Ie.cache++;
                var r, n, i = _();
                f && (n = (r = m()) + .05 * i * -e.velocityX / .227, i *= sc(m, r, n, Qa(p, ze)), a.vars.scrollX = S(n)), n = (r = b()) + .05 * i * -e.velocityY / .227, i *= sc(b, r, n, Qa(p, Ye)), a.vars.scrollY = C(n), a.invalidate().duration(i).play(.01), (E && a.vars.scrollY >= o || o - 1 <= r) && Fe.to({}, { onUpdate: Dq, duration: i })
            } else s.restart(!0);
            d && d(e)
        }, e.onWheel = function() { a._ts && a.pause(), 1e3 < ot() - w && (l = 0, w = ot()) }, e.onChange = function(e, t, r, n, i) {
            if (Ct !== l && wq(), t && f && m(S(n[2] === t ? c + (e.startX - e.x) : m() + t - n[1])), r) {
                b.offset && xq();
                var o = i[2] === r,
                    a = o ? u + e.startY - e.y : b() + r - i[1],
                    s = C(a);
                o && a !== s && (u += s - a), b(s)
            }(r || t) && Z()
        }, e.onEnable = function() { tc(p, !f && "x"), ne.addEventListener("refresh", Dq), wb(He, "resize", Dq), b.smooth && (b.target.style.scrollBehavior = "auto", b.smooth = m.smooth = !1), T.enable() }, e.onDisable = function() { tc(p, !0), xb(He, "resize", Dq), ne.removeEventListener("refresh", Dq), T.kill() }, e.lockAxis = !1 !== e.lockAxis, ((n = new k(e)).iOS = E) && !b() && b(1), E && Fe.ticker.add(Ha), s = n._dc, a = Fe.to(n, { ease: "power4", paused: !0, scrollX: f ? "+=0.1" : "+=0", scrollY: "+=0.1", modifiers: { scrollY: oc(b, b(), function() { return a.pause() }) }, onUpdate: Z, onComplete: s.vars.onComplete }), n
    }
    var ie, oe = { auto: 1, scroll: 1 },
        ae = /(input|label|select|textarea)/i,
        se = function _captureInputs(e) {
            var t = ae.test(e.target.tagName);
            (t || ie) && (e._gsapAllow = !0, ie = t)
        };
    ne.sort = function(e) { return Tt.sort(e || function(e, t) { return -1e6 * (e.vars.refreshPriority || 0) + e.start - (t.start + -1e6 * (t.vars.refreshPriority || 0)) }) }, ne.observe = function(e) { return new k(e) }, ne.normalizeScroll = function(e) { if (void 0 === e) return v; if (!0 === e && v) return v.enable(); if (!1 === e) return v && v.kill(), void(v = e); var t = e instanceof k ? e : Ac(e); return v && v.target === t.target && v.kill(), La(t.target) && (v = t), t }, ne.core = { _getVelocityProp: L, _inputObserver: wc, _scrollers: Ie, _proxies: Le, bridge: { ss: function ss() { at || U("scrollStart"), at = ot() }, ref: function ref() { return Ke } } }, Ka() && Fe.registerPlugin(ne), e.ScrollTrigger = ne, e.default = ne;
    if (typeof(window) === "undefined" || window !== e) { Object.defineProperty(e, "__esModule", { value: !0 }) } else { delete e.default }
});